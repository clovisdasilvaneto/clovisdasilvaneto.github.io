{"componentChunkName":"component---src-templates-blog-template-index-js","path":"/explorando-javascript-filter-reduce-map-every-some-e-foreach","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Explorando o javascript. filter, forEach, map, reduce, every e some","path":"/explorando-javascript-filter-reduce-map-every-some-e-foreach"},"html":"<h2>O Problema...</h2>\n<p>Se você atua à algum tempo na área, já pode ter passado por uma situação onde você precisa iterar um array só para verificar se existe alguma propriedade em um determinado indice, ou então somar alguma propriedade do mesmo.</p>\n<p><em>E ai? Qual seria a forma mais peformática de se execultar tal tarefa?</em></p>\n<h2>O forEach</h2>\n<p>O método forEach é bastante parecido com o for antigo, básicamente faz o mesmo que ele, mas numa forma bem mais elegante, vejamos abaixo um exemplo de uma iteração num determinado array usando o for e outra iteração usando forEach</p>\n<deckgo-highlight-code javascript   highlight-lines=\"\">\n          <code slot=\"code\">const users = [\n  { name: &quot;clóvis&quot;, id: 1, active: true },\n  { name: &quot;silva&quot;, id: 2, active: false },\n  { name: &quot;neto&quot;, id: 3, active: true },\n]\n\nfor (const i = 0; i &lt; users.length; i++) {\n  console.log(users[i].name)\n}\n\n//olha que diferença...\nusers.forEach(function (user) {\n  console.log(user.name)\n})</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>Tudo que é mais simples, acaba sendo mais interessante de se usar no dia-a-dia ;)</p>\n</blockquote>\n<p>Conhecendo este jeito lindo e simples de se trabalhar com o for (falo 'for' me referindo a forEach), vários dev's estagnados não se perguntam se existem ainda uma melhor forma de iterar um array para cada situação especifica, e outras séries de operações do array são simplesmente ignoradas por eles. Infelizmente este é o cenário atual que acontece aqui no Brasil :'( , mas vamos continuar o post...</p>\n<h2>Filtrando o array com o <span>filter</span></h2>\n<p>Imagine o seguinte array:</p>\n<deckgo-highlight-code javascript   highlight-lines=\"\">\n          <code slot=\"code\">let users = [\n  { name: &quot;clóvis&quot;, id: 1, active: true },\n  { name: &quot;silva&quot;, id: 2, active: false },\n  { name: &quot;neto&quot;, id: 3, active: true },\n]</code>\n        </deckgo-highlight-code>\n<p>Agora pense, que você queira trazer apenas os objetos que tenham como propriedade o <span>active:true</span>, como os dev's de agências desatualizados fariam? (nada contra)</p>\n<deckgo-highlight-code javascript   highlight-lines=\"\">\n          <code slot=\"code\">const data = []\n\n//repara no começo de um hadouken\nusers.forEach(function (user) {\n  if (user.active) {\n    data.push(user)\n  }\n})</code>\n        </deckgo-highlight-code>\n<p>Sempre que me deparo com situações assim, imagino duas respostas, rs</p>\n<p><strong>- Dev. desatualizado:</strong></p>\n<p>\"Maan, beleza... você conseguiu terminar o seu projeto, se preocupa com isso não pow, TÁ RODANDO shaushua.\"</p>\n<p><strong>- Dev. de verdade:</strong></p>\n<p>\"Tem como fazer melhor!...\"</p>\n<p>Vejamos com o filter como ficaria:</p>\n<deckgo-highlight-code javascript   highlight-lines=\"\">\n          <code slot=\"code\">// cade o hadouken??\nusers = users.filter(function (user) {\n  return user.active\n})</code>\n        </deckgo-highlight-code>\n<p>O método filter() cria um novo array com todos os elementos que passaram ao teste, no nosso caso o user que contém a propriedade <span>active</span>.</p>\n<h2>Every</h2>\n<p>O método every, testa todo os elementos da array passam no teste executado pela função em que fornecemos. Ex:</p>\n<deckgo-highlight-code javascript   highlight-lines=\"\">\n          <code slot=\"code\">const monthlyPayment = [\n  { month: &quot;jan&quot;, payday: true },\n  { month: &quot;fev&quot;, payday: true },\n  { month: &quot;mar&quot;, payday: true },\n  { month: &quot;abr&quot;, payday: true },\n  { month: &quot;mai&quot;, payday: true },\n]\n\nlet payments = monthlyPayment.every(function (month) {\n  return month.payday\n})\n\n//payments == true ;)</code>\n        </deckgo-highlight-code>\n<h2>Some</h2>\n<p>O método some faz basicamente o mesmo que o every, a única diferença é que ele testa se algum elemento do array passa no teste executado pela função que foi fornecida... Ex:</p>\n<deckgo-highlight-code javascript   highlight-lines=\"\">\n          <code slot=\"code\">const monthlyPayment = [\n  { month: &quot;jan&quot;, payday: true },\n  { month: &quot;fev&quot;, payday: false },\n  { month: &quot;mar&quot;, payday: false },\n  { month: &quot;abr&quot;, payday: false },\n  { month: &quot;mai&quot;, payday: true },\n]\n\nlet payments = monthlyPayment.some(function (month) {\n  return month.payday\n})\n\n//payments == true ;)</code>\n        </deckgo-highlight-code>\n<h2>Map</h2>\n<p>Através do map, podemos criar um novo array, derivando-se do array atual.</p>\n<p>Imagine que seu chefe lhe trouxe um punhado cheio jóias e bijuterias (\"ah jura?\") e lhe pediu para você retirar apenas as jóias de ouro e guardar numa caixa. O método map faz exatamente isto, ele pecorre o array, trazendo apenas o valor retornado. Ex:</p>\n<deckgo-highlight-code javascript   highlight-lines=\"\">\n          <code slot=\"code\">const monthlyPayment = [\n  { name: &quot;jan&quot;, payday: true },\n  { name: &quot;fev&quot;, payday: false },\n  { name: &quot;mar&quot;, payday: false },\n  { name: &quot;abr&quot;, payday: false },\n  { name: &quot;mai&quot;, payday: true },\n]\n\nlet months = monthlyPayment.map(function (month) {\n  return month.name\n})\n\n//months == [&#39;jan&#39;, &#39;fev&#39;, &#39;mar&#39;, &#39;abr&#39;, &#39;maio&#39;])</code>\n        </deckgo-highlight-code>\n<h2>Reduce</h2>\n<p>Podemos criar uma acumulação de valores no array utilizando o método reduce. Ex:</p>\n<deckgo-highlight-code javascript   highlight-lines=\"\">\n          <code slot=\"code\">const monthlyPayment = [\n  { name: &quot;jan&quot;, payday: 1400 },\n  { name: &quot;fev&quot;, payday: 100 },\n  { name: &quot;mar&quot;, payday: 1300 },\n  { name: &quot;abr&quot;, payday: 400 },\n  { name: &quot;mai&quot;, payday: 800 },\n]\n\nlet result = monthlyPayment.reduce(function (currentSum, currentMonth) {\n  return currentSum + currentMonth.payday\n}, 0)\n\n//result == 4000)</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>note que após o fechamento da função, colocamos um '0' para que o primeiro valor seja igual à 0. Logo quando entrarmos no primeiro loop, do método reduce, o currentSum será igual à 0, e nos loops seguinte o currentSum será a soma dos dias pagos('payday').</p>\n</blockquote>\n<p>Um bom material para podermos estudar o core da linguagem é a documentação da MDN, apartir deste conteúdo, você pode estar se aprofundando mais na linguagem javascript, segue abaixo:</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript\">Clica aqui :p</a></p>\n<h2>Conclusão</h2>\n<p>É muuuiito importante ficar ligado nestes métodos e nos que virão, pois a partir deles deixamos nosso código limpo, fácil de entender e bastante peformático.</p>\n<p><em>Obrigado e até o próximo post \\o/</em></p>"}},"pageContext":{}},"staticQueryHashes":[]}